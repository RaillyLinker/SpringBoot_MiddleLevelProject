# 포트폴리오 토이 프로젝트 (Springboot)

## 프로젝트 설명

본 프로젝트는 작성자의 개발 능력 검증용 토이 프로젝트입니다.<br>
<br>
Layered 멀티 모듈 아키텍쳐를 사용하였으며,<br>
모듈 분리의 기준은 독립적 기능 중심 분리에서 시작하여 서비스 구현으로 나뉘어집니다.<br>
<br>
모듈은 idp, dpd, api 의 세가지 종류로 나누었습니다.<br>

1. 다른 모듈에 종속성이 없는 independent(idp) 모듈
2. 서버 API 컨트롤러 개발용 api(api) 모듈
3. 그 외의 종속성을 가진 dependent(dpd) 모듈

위와 같이 구분하여,<br>
모듈화의 최대 장점인 관심사의 분리와 결합성/의존성의 최소화를 이루어냈습니다.<br>
<br>

### 구성 모듈 설명

![화면 캡처 2024-10-18 090100](https://github.com/user-attachments/assets/6535f464-7bf7-4503-ae24-f880717c85ff)

1. module-api-service-v1 :<br>
   서비스 API 가 구현되어 모여있는 모듈 (main 버전 단위 분리)
2. module-idp-common :<br>
   다른 모듈에 종속성이 없는 유틸성 클래스를 모아둔 모듈
3. module-idp-jpa :<br>
   다른 모듈에 종속성이 없는 JPA Entity, Repository, QueryDSL 을 모아둔 모듈

### 프로젝트 구조 설명

![화면 캡처 2024-10-18 200236](https://github.com/user-attachments/assets/45d1fe13-44e7-45bb-b876-979a12c6d40c)

- by_product_files : 프로젝트 실행시 생성되는 모든 파일 분산물은 이곳에 저장됩니다.<br>
  대표적으로 로그 파일이 있으며, .gitignore 에 설정됩니다.
- external_files : 임의로 추가한 외부 파일들을 모아둔 폴더입니다.<br>
  본 프로젝트에서는 프로젝트를 실행시키기 위한 최소 환경을 간편하게 구성해주는 docker-compose 파일이 저장되어 있습니다.<br>
- module-* : 위 모듈 설명과 동일.

### 프로젝트 실행

1. external_files 의 mariadb 도커 컨테이너를 실행하거나, mariadb 설치
2. module-idp-jpa 의 src/main/java/raillylinker/module_idp_jpa/data_sources/entities/*<br>
   를 참고하여 mariadb 의 데이터베이스 테이블 구조를 맞춰주기.<br>
   (module-idp-jpa 의 application.yml 파일에서 ddl-auto 설정을 사용하는 방식도 있습니다.)
3. 상기한 준비가 완료되었다면 module-api-service-v1 의 ApplicationMain 을 실행시켜줍니다.
4. 로컬 웹 브라우저에서 127.0.0.1:8080 주소로 서비스에 접근하여 웰컴 페이지로 진입이 가능하며,<br>
   "API 문서로 이동" 버튼을 클릭하여 Swagger API 문서 페이지로 진입하여 API 확인 및 기능 테스트를 수행할 수 있습니다.

![화면 캡처 2024-10-18 200515](https://github.com/user-attachments/assets/e5e7c13b-d631-4550-9055-cc1d3c9c5317)

## 프로젝트 설명 상세

### 개발 조건

개발 조건은 2024년도 현 시점 백엔드 개발자 풀의 보편적인 기술들을 사용합니다.

1. 개발 언어는 Java17, <br>
   빌드툴은 Gradle<br>
   프레임워크는 Springboot MVC, <br>
   데이터베이스 ORM 라이브러리는 JPA(QueryDSL 사용) 을 사용합니다.<br>
   <br>
2. 데이터베이스 외 미들웨어, 그외 사용 라이브러리는 따로 사용하지 않았고,<br>
   프로젝트 구조를 단순화 하여 가독성을 높이기 위하여 MariaDB 만을 사용하였습니다.<br>
   Redis 를 이용한 분산락, Kafka 를 이용한 작업 큐 구현 등의 미들웨어 성능 개선 가능 부분은,<br>
   주석으로 알고리즘을 설명해두었습니다.<br>

### 구현할 기능

본 프로젝트에서 구현한 기능은 두가지입니다.<br>

1. 프리랜서 프로필 조회 서비스 구현<br>
   (Database ORM 활용 능력, 데이터베이스 비동기 처리 및 대용량 트래픽 처리 기본 능력)
2. 포인트 충전 결제 서비스 구현<br>
   (실무 서비스 설계 능력, 예외 처리 능력, 종합 개발 능력)

### 구현할 기능 상세

#### [프리랜서 프로필 조회 서비스]

1. 등록된 프리렌서의 프로필 목록을 조회하는 API<br>
   검색 결과 Sorting(이름 가나다 순, 조회 수 순, 등록 최신 순) 기능을 지원하며,<br>
   검색 리스트는 Pagination 형태,<br>
   조회시 각 프로필은 "프리랜서의 이름, 프로필 상세 조회 수, 프로필 등록 날짜"가 포함되어야 합니다.<br>
   <br>
2. 프리렌서 프로필 상세 조회 수 업데이트 API<br>
   프로필 상세를 조회할 경우 호출되는 '조회수 업데이트 API' 구현<br>
   업데이트된 조회수는 프리랜서 목록 조회 API 결과값에 반영되어야 하며,<br>
   조회수가 즉시 반영될 필요가 없지만 대량의 트래픽을 고려하여 구현해야 합니다.

#### [포인트 충전 서비스]

1. 결제를 통해 자사서비스의 포인트를 충전하는 서비스를 구현합니다.<br>
   클라이언트 API 는 완성되어있으며, <br>
   인증/인가 구현은 생략하고, 앞서 구현한 프리랜서가 포인트를 충전한다고 가정하여 서버 API 를 구현합니다.
    - 토스페이먼츠 기준 결제 서비스 구현
    - 포인트 적립 비율은 원화와 1:1(ex : 1만원 결제시 1만 포인트 적립)<br>
    - 추후 다른 PG 사로 대체, 추가 할 수 있도록 유연하게 구현<br>
    - 장애 발생을 고려한 예외처리
    - 할인 쿠폰 기능을 구현하며,
      추가 포인트 적립 이벤트 등의 다양한 가격 정책이 추가될 것을 가정

### 개발 중점 사항

1. 객체지향적 설계 - 올바른 코딩 기본기를 갖추고 있는지
2. 예외처리를 통한 안정성 확보 - 꼼꼼한 업무 수행 능력과 자신이 다루는 기술을 이해하고 있는지
3. 대량 트래픽 및 동시성 고려 - 개발 능력에 실전성을 갖추고 있는지

### 구현 설명
#### [프리랜서 프로필 조회 서비스]
1. C2FreelancerServiceImpl.api2SelectFreelancersPage<br>
   QueryDSL 을 사용하여 Join 데이터를 페이징 하여 가져왔으며<br>
   sortingType 변수에 따라 결과 Sorting 을 다르게 하였습니다.<br>
   추가적으로 아이템 총 개수를 반환하였으며, 데이터베이스 테이블 고유값을 반환할 때에는 보안을 위하여 암호화 처리를 하였습니다.<br>
   <br>
2. C2FreelancerServiceImpl.api3Plus1FreelancerView<br>
   응답이 필요한 류의 API 가 아니므로 요청을 받자마자 200 응답을 반환하도록 처리하였고,<br>
   정보 조회시 데이터가 수정되는 구조와 더불어 대용량 트래픽을 가정하여 작업을 별도 스레드에서 처리하도록 하였습니다.<br>
   이 부분은 Kafka 와 같은 이벤트 스트리밍 서비스로 작업 분산을 시킬 수 있으므로 주석에 설계를 남겨두었으며,<br>
   비동기적 실행으로 발생하는 수정 데이터의 경쟁 상태에 대한 대비로 함수에 락을 걸어 한번에 하나의 스레드만이 작업을 진행할 수 있게 하였습니다.<br>
   이 부분 역시 Redis 분산락을 사용할 수 있으며, 이에 대한 주석 설계를 남겨두었습니다.

#### [포인트 충전 서비스]

1. C3PointServiceImpl.api1TossPayServicePoint<br>
   <img width="640" alt="다운로드" src="https://github.com/user-attachments/assets/40f2aa60-8e70-407f-890e-00bbb8733181"><br>
   토스 결제 API 흐름은 위 도표를 따릅니다. <br>
   - 이 함수는 토스 결제만을 위한 결제 승인 API 로, 만약 추후 다른 결제 방식을 구현한다면, 별도의 API 를 생성하며, 내부적으로 공용 결제 데이터가 저장되는 데이터베이스만을 공유하면 되도록 구분해두었습니다.<br>
   - nowFreelancerUidList 라는 유저 uid 리스트에 현재 결제가 진행중인 유저의 고유번호를 입력하고,<br>
   semaphore 를 사용하여 처리함으로써 한 유저가 동시에 결제를 진행할 수는 없도록 설계하여 결제의 비동기 안정성을 구현하였습니다.<br>
   - 프리랜서 uid 를 인증 정보로 사용하였으며, 입력받은 암호화된 uid 를 해석하는 것으로 인증/인가 절차를 대신하였습니다. 이 부분은 언제든 다른 인증 인가 체계로 수정이 가능합니다.<br>
   - 토스 페이의 결제 방식은 위 도표를 따르며, 그에 맞는 결제 정보를 받아와 입력하고 결제 승인 요청을 하였습니다.<br>
   토스 페이에서 결제가 실패하면 실패한 이유를 클라이언트에게 반환하고,<br>
   결제가 성공했다면 데이터베이스에 입력할 포인트 계산을 시작합니다.<br>
   - 포인트 계산시에는 포인트 비율 상수와 곱하여 가격 -> 포인트 변환을 먼저 진행하고, 이후 별도의 이벤트로 인한 추가 포인트 등의 요소를 extraPointEvent 함수에서 처리하도록 설계했습니다.<br>
   포인트 계산이 완료되면 데이터베이스에서 기존 포인트를 가져와서 새로운 포인트와 합산하여 저장하고,<br>
   추후 환불을 고려하여 결제 히스토리 및 토스 페이 결제 취소용 데이터를 저장합니다.<br>
   - 결제 이후 로직에서 혹시라도 모를 런타임 에러가 발생할 것을 고려하여 try catch 문을 사용하였고,<br>
   만약 에러가 발생했다면 자동으로 토스 페이로 결제 취소가 되도록 하였으며,<br>
   자동 결제 취소도 실패한 경우 담당자가 수동으로 처리하도록 실패 정보가 저장되고 메시지가 전송하도록 설계하였습니다.<br>
   이때, 데이터베이스 @Transactional 의 롤백이 동작하도록 RuntimeException 을 throw 해주었습니다.
